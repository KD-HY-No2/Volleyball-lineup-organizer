<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Lineup Optimizer</title>
    <meta name="description" content="Professional volleyball lineup optimization with star player management">
    <meta name="theme-color" content="#8b5cf6">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Volleyball Optimizer">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
                overflow-x: hidden;
            }
        }

        ::-webkit-scrollbar {
            width: 3px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .drop-zone-active {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 2px dashed #3b82f6 !important;
        }

        .optimizing {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            animation: pulse 2s infinite;
        }

        .star-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border-color: #ffd700 !important;
        }

        .install-prompt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const VolleyballApp = () => {
            // PWA Install State
            const [deferredPrompt, setDeferredPrompt] = useState(null);
            const [showInstallPrompt, setShowInstallPrompt] = useState(false);

            // Load data from localStorage on startup
            const loadFromStorage = (key, defaultValue) => {
                try {
                    const saved = localStorage.getItem(key);
                    return saved ? JSON.parse(saved) : defaultValue;
                } catch (error) {
                    console.warn(`Error loading ${key} from storage:`, error);
                    return defaultValue;
                }
            };

            // Save data to localStorage
            const saveToStorage = (key, data) => {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                } catch (error) {
                    console.warn(`Error saving ${key} to storage:`, error);
                }
            };

            // Initialize with saved data or defaults
            const [players, setPlayers] = useState(() => loadFromStorage('volleyball_players', [
                { id: 1, name: '1', defense: 3, serving: 3, active: true, star: false },
                { id: 2, name: '2', defense: 3, serving: 3, active: true, star: false },
                { id: 3, name: '3', defense: 3, serving: 3, active: true, star: false },
                { id: 4, name: '4', defense: 3, serving: 3, active: true, star: false },
                { id: 5, name: '5', defense: 3, serving: 3, active: true, star: false },
                { id: 6, name: '6', defense: 3, serving: 3, active: true, star: false },
                { id: 7, name: '7', defense: 3, serving: 3, active: true, star: false },
                { id: 8, name: '8', defense: 3, serving: 3, active: true, star: false },
                { id: 9, name: '9', defense: 3, serving: 3, active: true, star: false },
                { id: 10, name: '10', defense: 3, serving: 3, active: true, star: false }
            ]));

            const [showPlayerForm, setShowPlayerForm] = useState(false);
            const [editingPlayer, setEditingPlayer] = useState(null);
            const [teamName, setTeamName] = useState(() => loadFromStorage('volleyball_teamName', 'My Team'));
            const [minThreshold, setMinThreshold] = useState(() => loadFromStorage('volleyball_minThreshold', 6));
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [draggedPlayer, setDraggedPlayer] = useState(null);
            const [dropZone, setDropZone] = useState(null);
            const [bestLineups, setBestLineups] = useState([]);
            const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

            // Form state
            const [playerForm, setPlayerForm] = useState({
                name: '',
                defense: 3,
                serving: 3,
                active: true,
                star: false
            });

            // Court positions (6 on court, rest on bench)
            const [courtPositions, setCourtPositions] = useState({
                backLeft: null,    // Position 1 - Serving position
                frontLeft: null,   // Position 2
                frontMiddle: null, // Position 3
                frontRight: null,  // Position 4
                backRight: null,   // Position 5
                backMiddle: null,  // Position 6
                bench: []
            });

            // Save to localStorage whenever data changes
            useEffect(() => {
                saveToStorage('volleyball_players', players);
            }, [players]);

            useEffect(() => {
                saveToStorage('volleyball_teamName', teamName);
            }, [teamName]);

            useEffect(() => {
                saveToStorage('volleyball_minThreshold', minThreshold);
            }, [minThreshold]);

            // PWA Install Prompt Handling
            useEffect(() => {
                const handleBeforeInstallPrompt = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    setShowInstallPrompt(true);
                };

                const handleAppInstalled = () => {
                    setShowInstallPrompt(false);
                    setDeferredPrompt(null);
                };

                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                window.addEventListener('appinstalled', handleAppInstalled);

                return () => {
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, []);

            // Register Service Worker
            useEffect(() => {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then((registration) => {
                            console.log('SW registered: ', registration);
                        })
                        .catch((registrationError) => {
                            console.log('SW registration failed: ', registrationError);
                        });
                }
            }, []);

            const handleInstallClick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    if (outcome === 'accepted') {
                        setShowInstallPrompt(false);
                    }
                    setDeferredPrompt(null);
                }
            };

            const handleAddPlayer = () => {
                if (playerForm.name.trim()) {
                    const newPlayer = {
                        id: Date.now(),
                        ...playerForm
                    };
                    setPlayers([...players, newPlayer]);
                    setPlayerForm({ name: '', defense: 3, serving: 3, active: true, star: false });
                    setShowPlayerForm(false);
                }
            };

            const handleEditPlayer = (player) => {
                if (draggedPlayer) return; // Don't edit while dragging
                setEditingPlayer(player.id);
                setPlayerForm(player);
                setShowPlayerForm(true);
            };

            const handleUpdatePlayer = () => {
                setPlayers(players.map(p => 
                    p.id === editingPlayer ? { ...playerForm, id: editingPlayer } : p
                ));
                setEditingPlayer(null);
                setPlayerForm({ name: '', defense: 3, serving: 3, active: true, star: false });
                setShowPlayerForm(false);
            };

            const togglePlayerActive = (id) => {
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, active: !p.active } : p
                ));
            };

            const togglePlayerStar = (id) => {
                const currentStars = players.filter(p => p.star).length;
                const targetPlayer = players.find(p => p.id === id);
                
                // If trying to add a star and already have 3, don't allow
                if (!targetPlayer.star && currentStars >= 3) {
                    return;
                }
                
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, star: !p.star } : p
                ));
            };

            // Helper function to check star player rules
            const checkStarRules = (positions) => {
                const courtPlayers = [
                    positions.backLeft,
                    positions.frontLeft,
                    positions.frontMiddle,
                    positions.frontRight,
                    positions.backRight,
                    positions.backMiddle
                ].filter(Boolean);

                const starsOnCourt = courtPlayers.filter(p => p.star).length;
                
                // Must have at least 1 star on court
                if (starsOnCourt === 0) return false;

                // Check if stars are adjacent in rotation order
                const starPositions = [];
                if (positions.backLeft?.star) starPositions.push(1);
                if (positions.frontLeft?.star) starPositions.push(2);
                if (positions.frontMiddle?.star) starPositions.push(3);
                if (positions.frontRight?.star) starPositions.push(4);
                if (positions.backRight?.star) starPositions.push(5);
                if (positions.backMiddle?.star) starPositions.push(6);

                // Check for adjacent positions (including wraparound 6->1)
                for (let i = 0; i < starPositions.length; i++) {
                    for (let j = i + 1; j < starPositions.length; j++) {
                        const pos1 = starPositions[i];
                        const pos2 = starPositions[j];
                        
                        // Adjacent if difference is 1, or if they are 1 and 6 (wraparound)
                        if (Math.abs(pos1 - pos2) === 1 || (pos1 === 1 && pos2 === 6) || (pos1 === 6 && pos2 === 1)) {
                            return false;
                        }
                    }
                }

                return true;
            };

            // Calculate rotation strengths
            const calculateRotationStrengths = (positions) => {
                const rotations = [];
                let currentPositions = { ...positions };
                
                for (let i = 0; i < 10; i++) { // Calculate 10 rotations
                    const frontRowTotal = (currentPositions.frontLeft?.defense || 0) + 
                                         (currentPositions.frontMiddle?.defense || 0) + 
                                         (currentPositions.frontRight?.defense || 0);
                    const backRowTotal = (currentPositions.backLeft?.defense || 0) + 
                                        (currentPositions.backMiddle?.defense || 0) + 
                                        (currentPositions.backRight?.defense || 0);
                    
                    rotations.push({
                        frontRowTotal,
                        backRowTotal,
                        serverRating: currentPositions.backLeft?.serving || 0,
                        rotation: i
                    });
                    
                    // Simulate rotation
                    const newPositions = {
                        backRight: currentPositions.backMiddle,
                        frontRight: currentPositions.backRight,
                        frontMiddle: currentPositions.frontRight,
                        frontLeft: currentPositions.frontMiddle,
                        backLeft: currentPositions.frontLeft,
                        bench: [...currentPositions.bench]
                    };
                    
                    const newBench = [...currentPositions.bench];
                    if (newBench.length > 0) {
                        newBench.push(currentPositions.backLeft);
                        newPositions.backMiddle = newBench.shift();
                    } else {
                        newPositions.backMiddle = currentPositions.backLeft;
                    }
                    newPositions.bench = newBench;
                    
                    currentPositions = newPositions;
                }
                
                return rotations;
            };
// Standard Play Optimization Algorithm with Star Rules
            const optimizeStandardPlay = async () => {
                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const starPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    setIsOptimizing(false);
                    return;
                }

                // Must have at least 1 star player active for star rules to apply
                if (starPlayers.length === 0) {
                    alert("Please select at least 1 star player to use optimization.");
                    setIsOptimizing(false);
                    return;
                }

                // Find top 3 defensive players
                const sortedByDefense = [...activePlayers].sort((a, b) => b.defense - a.defense);
                const top3Defenders = sortedByDefense.slice(0, 3);

                let allLineups = [];

                // Generate all possible combinations of 6 players from active players
                const combinations = [];
                const generateCombinations = (arr, size, start = 0, current = []) => {
                    if (current.length === size) {
                        combinations.push([...current]);
                        return;
                    }
                    for (let i = start; i < arr.length; i++) {
                        current.push(arr[i]);
                        generateCombinations(arr, size, i + 1, current);
                        current.pop();
                    }
                };
                
                generateCombinations(activePlayers, 6);

                // Filter combinations to ensure at least 1 star player
                const validCombinations = combinations.filter(combo => 
                    combo.some(player => player.star)
                );

                for (const combo of validCombinations) {
                    const permutations = [];
                    const generatePermutations = (arr, current = []) => {
                        if (current.length === arr.length) {
                            permutations.push([...current]);
                            return;
                        }
                        for (let i = 0; i < arr.length; i++) {
                            if (!current.includes(arr[i])) {
                                current.push(arr[i]);
                                generatePermutations(arr, current);
                                current.pop();
                            }
                        }
                    };
                    
                    generatePermutations(combo);

                    for (const perm of permutations) {
                        const testPositions = {
                            backLeft: perm[0],
                            frontLeft: perm[1],
                            frontMiddle: perm[2],
                            frontRight: perm[3],
                            backRight: perm[4],
                            backMiddle: perm[5],
                            bench: activePlayers.filter(p => !combo.includes(p))
                        };

                        // Check star player rules
                        if (!checkStarRules(testPositions)) continue;

                        // Check if at least one top 3 defender is in back row
                        const backRowPlayers = [testPositions.backLeft, testPositions.backMiddle, testPositions.backRight];
                        const hasTopDefenderInBack = backRowPlayers.some(player => 
                            top3Defenders.some(topDef => topDef.id === player.id)
                        );

                        const rotations = calculateRotationStrengths(testPositions);
                        
                        // Calculate score
                        let aboveThresholdCount = 0;
                        let totalDefense = 0;
                        let servingScore = 0;
                        let topDefenderInBackCount = 0;
                        let starBonus = 0;

                        rotations.forEach((rotation, index) => {
                            if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                                aboveThresholdCount++;
                            }
                            totalDefense += rotation.frontRowTotal + rotation.backRowTotal;
                            
                            const rotationWeight = Math.max(1, 10 - index);
                            servingScore += rotation.serverRating * rotationWeight;

                            // Simulate rotation for star count
                            let currentPos = { ...testPositions };
                            for (let r = 0; r < index; r++) {
                                const newPos = {
                                    backRight: currentPos.backMiddle,
                                    frontRight: currentPos.backRight,
                                    frontMiddle: currentPos.frontRight,
                                    frontLeft: currentPos.frontMiddle,
                                    backLeft: currentPos.frontLeft,
                                    bench: [...currentPos.bench]
                                };
                                const newBench = [...currentPos.bench];
                                if (newBench.length > 0) {
                                    newBench.push(currentPos.backLeft);
                                    newPos.backMiddle = newBench.shift();
                                } else {
                                    newPos.backMiddle = currentPos.backLeft;
                                }
                                newPos.bench = newBench;
                                currentPos = newPos;
                            }
                            
                            const rotBackRowPlayers = [currentPos.backLeft, currentPos.backMiddle, currentPos.backRight];
                            if (rotBackRowPlayers.some(player => 
                                player && top3Defenders.some(topDef => topDef.id === player.id)
                            )) {
                                topDefenderInBackCount++;
                            }

                            // Star bonus: prefer 2 stars on court
                            const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle, 
                                                currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
                            const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
                            if (starsOnCourt >= 2) starBonus += 5;
                        });

                        const avgDefense = totalDefense / rotations.length;
                        const thresholdPercent = aboveThresholdCount / rotations.length;
                        const topDefenderPercent = topDefenderInBackCount / rotations.length;
                        
                        // Enhanced score with star bonus
                        const score = (topDefenderPercent * 150) + (thresholdPercent * 100) + (avgDefense * 2) + (servingScore * 0.1) + starBonus;

                        allLineups.push({
                            positions: testPositions,
                            score: score,
                            thresholdPercent: thresholdPercent,
                            avgDefense: avgDefense,
                            topDefenderPercent: topDefenderPercent,
                            starBonus: starBonus
                        });
                    }

                    if (validCombinations.indexOf(combo) > 500) break; // Limit for performance
                }

                allLineups.sort((a, b) => b.score - a.score);
                const topLineups = allLineups.slice(0, 10);
                
                setBestLineups(topLineups);
                setCurrentLineupIndex(0);

                if (topLineups.length > 0) {
                    setCourtPositions(topLineups[0].positions);
                }
                
                setIsOptimizing(false);
            };

            // Serving Priority Optimization with Star Rules
            const optimizeServingPriority = async () => {
                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const starPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    setIsOptimizing(false);
                    return;
                }

                if (starPlayers.length === 0) {
                    alert("Please select at least 1 star player to use optimization.");
                    setIsOptimizing(false);
                    return;
                }

                // Find eligible first servers (serving >= 3) who are stars first, then non-stars
                let eligibleServers = starPlayers.filter(p => p.serving >= 3);
                if (eligibleServers.length === 0) {
                    eligibleServers = activePlayers.filter(p => p.serving >= 3);
                }
                if (eligibleServers.length === 0) {
                    eligibleServers = [...starPlayers].sort((a, b) => b.serving - a.serving).slice(0, 1);
                }
                
                const firstServer = eligibleServers.sort((a, b) => a.defense - b.defense)[0];
                const remainingPlayers = activePlayers.filter(p => p.id !== firstServer.id);
                const topServers = remainingPlayers.sort((a, b) => b.serving - a.serving).slice(0, 5);
                const benchPlayers = remainingPlayers.filter(p => !topServers.some(ts => ts.id === p.id))
                    .sort((a, b) => b.defense - a.defense);

                let allLineups = [];

                const generatePermutations = (arr, current = []) => {
                    if (current.length === arr.length) {
                        return [current];
                    }
                    const perms = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (!current.includes(arr[i])) {
                            const newCurrent = [...current, arr[i]];
                            perms.push(...generatePermutations(arr, newCurrent));
                        }
                    }
                    return perms;
                };

                const serverPermutations = generatePermutations(topServers);

                for (const perm of serverPermutations) {
                    const testPositions = {
                        backLeft: firstServer,
                        frontLeft: perm[0],
                        frontMiddle: perm[1],
                        frontRight: perm[2],
                        backRight: perm[3],
                        backMiddle: perm[4],
                        bench: benchPlayers
                    };

                    // Check star player rules
                    if (!checkStarRules(testPositions)) continue;

                    const rotations = calculateRotationStrengths(testPositions);
                    
                    let aboveThresholdCount = 0;
                    let totalDefense = 0;
                    let servingScore = 0;
                    let starBonus = 0;

                    rotations.forEach((rotation, index) => {
                        if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                            aboveThresholdCount++;
                        }
                        totalDefense += rotation.frontRowTotal + rotation.backRowTotal;
                        
                        const rotationWeight = Math.max(1, 20 - (index * 2));
                        servingScore += rotation.serverRating * rotationWeight;

                        // Star bonus for having 2 stars on court
                        let currentPos = { ...testPositions };
                        for (let r = 0; r < index; r++) {
                            const newPos = {
                                backRight: currentPos.backMiddle,
                                frontRight: currentPos.backRight,
                                frontMiddle: currentPos.frontRight,
                                frontLeft: currentPos.frontMiddle,
                                backLeft: currentPos.frontLeft,
                                bench: [...currentPos.bench]
                            };
                            const newBench = [...currentPos.bench];
                            if (newBench.length > 0) {
                                newBench.push(currentPos.backLeft);
                                newPos.backMiddle = newBench.shift();
                            } else {
                                newPos.backMiddle = currentPos.backLeft;
                            }
                            newPos.bench = newBench;
                            currentPos = newPos;
                        }

                        const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                                            currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
                        const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
                        if (starsOnCourt >= 2) starBonus += 3;
                    });

                    const avgDefense = totalDefense / rotations.length;
                    const thresholdPercent = aboveThresholdCount / rotations.length;
                    const score = (servingScore * 1.0) + (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

                    allLineups.push({
                        positions: testPositions,
                        score: score,
                        thresholdPercent: thresholdPercent,
                        avgDefense: avgDefense,
                        servingScore: servingScore,
                        starBonus: starBonus
                    });
                }

                allLineups.sort((a, b) => b.score - a.score);
                const topLineups = allLineups.slice(0, 10);
                
                setBestLineups(topLineups);
                setCurrentLineupIndex(0);

                if (topLineups.length > 0) {
                    setCourtPositions(topLineups[0].positions);
                }
                
                setIsOptimizing(false);
            };

            const shuffleStandardPlay = () => {
                if (bestLineups.length === 0) return;
                
                const nextIndex = (currentLineupIndex + 1) % bestLineups.length;
                setCurrentLineupIndex(nextIndex);
                setCourtPositions(bestLineups[nextIndex].positions);
            };
const autoArrangePlayers = () => {
                const activePlayers = players.filter(p => p.active);
                if (activePlayers.length < 6) return;

                const newPositions = {
                    backLeft: activePlayers.find(p => p.name === '1') || activePlayers[0],
                    frontLeft: activePlayers.find(p => p.name === '2') || activePlayers[1],
                    frontMiddle: activePlayers.find(p => p.name === '3') || activePlayers[2],
                    frontRight: activePlayers.find(p => p.name === '4') || activePlayers[3],
                    backRight: activePlayers.find(p => p.name === '5') || activePlayers[4],
                    backMiddle: activePlayers.find(p => p.name === '6') || activePlayers[5],
                    bench: activePlayers.slice(6)
                };
                setCourtPositions(newPositions);
            };

            const rotateForward = () => {
                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    backRight: courtPositions.backMiddle,
                    frontRight: courtPositions.backRight,
                    frontMiddle: courtPositions.frontRight,
                    frontLeft: courtPositions.frontMiddle,
                    backLeft: courtPositions.frontLeft,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.push(courtPositions.backLeft);
                
                if (newBench.length > 0) {
                    newPositions.backMiddle = newBench.shift();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            const rotateBackward = () => {
                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    frontLeft: courtPositions.backLeft,
                    frontMiddle: courtPositions.frontLeft,
                    frontRight: courtPositions.frontMiddle,
                    backRight: courtPositions.frontRight,
                    backMiddle: courtPositions.backRight,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.unshift(courtPositions.backMiddle);
                
                if (newBench.length > 0) {
                    newPositions.backLeft = newBench.pop();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            // Export team data
            const exportData = () => {
                const data = {
                    players,
                    teamName,
                    minThreshold,
                    courtPositions,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `volleyball_team_${teamName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            };

            // Import team data
            const handleImportData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (importedData.players) setPlayers(importedData.players);
                        if (importedData.teamName) setTeamName(importedData.teamName);
                        if (importedData.minThreshold) setMinThreshold(importedData.minThreshold);
                        if (importedData.courtPositions) setCourtPositions(importedData.courtPositions);
                        
                        alert('Team data imported successfully!');
                    } catch (error) {
                        alert('Error importing data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            // Drag and Drop handlers
            const handleDragStart = (e, player) => {
                setDraggedPlayer(player);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnter = (e, zone) => {
                e.preventDefault();
                setDropZone(zone);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDropZone(null);
            };

            const handleDrop = (e, targetPosition) => {
                e.preventDefault();
                if (!draggedPlayer) return;

                const newPositions = { ...courtPositions };
                
                let currentPosition = null;
                Object.keys(newPositions).forEach(pos => {
                    if (pos === 'bench') {
                        const benchIndex = newPositions[pos].findIndex(p => p.id === draggedPlayer.id);
                        if (benchIndex >= 0) {
                            currentPosition = { type: 'bench', index: benchIndex };
                        }
                    } else if (newPositions[pos] && newPositions[pos].id === draggedPlayer.id) {
                        currentPosition = { type: 'court', position: pos };
                    }
                });

                if (currentPosition) {
                    if (currentPosition.type === 'bench') {
                        newPositions.bench.splice(currentPosition.index, 1);
                    } else {
                        newPositions[currentPosition.position] = null;
                    }
                }

                if (targetPosition === 'bench') {
                    newPositions.bench.push(draggedPlayer);
                } else if (targetPosition.startsWith('bench-')) {
                    const index = parseInt(targetPosition.split('-')[1]);
                    newPositions.bench.splice(index, 0, draggedPlayer);
                } else {
                    if (newPositions[targetPosition]) {
                        if (currentPosition && currentPosition.type === 'court') {
                            newPositions[currentPosition.position] = newPositions[targetPosition];
                        } else if (currentPosition && currentPosition.type === 'bench') {
                            newPositions.bench.splice(currentPosition.index, 0, newPositions[targetPosition]);
                        }
                    }
                    newPositions[targetPosition] = draggedPlayer;
                }

                setCourtPositions(newPositions);
                setDraggedPlayer(null);
                setDropZone(null);
            };

            const currentStrengths = calculateRotationStrengths(courtPositions).slice(0, 6);

            const PlayerTile = ({ player, position, isOnCourt, benchIndex }) => (
                React.createElement('div', {
                    className: `p-3 rounded-lg shadow-md cursor-pointer transition-all ${
                        player.active 
                            ? (isOnCourt ? 'bg-blue-100 border-2 border-blue-500' : 'bg-green-100 border-2 border-green-400')
                            : 'bg-gray-200 border-2 border-gray-300'
                    } ${player.star ? 'star-player' : ''} ${draggedPlayer && draggedPlayer.id === player.id ? 'dragging' : ''}`,
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, player),
                    onClick: () => handleEditPlayer(player)
                },
                    React.createElement('div', { className: "flex items-center justify-between" },
                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                        player.star && React.createElement('span', { className: "text-yellow-500 text-sm" }, '⭐')
                    ),
                    position && React.createElement('div', { className: "text-xs text-gray-600 mt-1" }, position)
                )
            );

            const DropZone = ({ position, currentPlayer, label }) => (
                React.createElement('div', {
                    className: `h-16 border-2 border-dashed rounded-lg flex items-center justify-center transition-all ${
                        dropZone === position ? 'drop-zone-active' : 'border-gray-300'
                    }`,
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, position),
                    onDragLeave: handleDragLeave,
                    onDrop: (e) => handleDrop(e, position)
                },
                    currentPlayer ? 
                        React.createElement(PlayerTile, { player: currentPlayer, position: label, isOnCourt: true }) :
                        React.createElement('span', { className: "text-xs text-gray-400" }, "Empty")
                )
            );
React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('label', { className: "block text-sm font-medium" }, "Star Player"),
                                    React.createElement('button', {
                                        onClick: () => setPlayerForm({...playerForm, star: !playerForm.star}),
                                        className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                            playerForm.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                        }`,
                                        type: "button"
                                    },
                                        React.createElement('span', { className: "text-xs" }, playerForm.star ? '⭐' : '☆')
                                    
                                )
                            ),
                            
                            React.createElement('div', { className: "flex gap-3 mt-6" },
                                React.createElement('button', {
                                    onClick: () => {
                                        setShowPlayerForm(false);
                                        setEditingPlayer(null);
                                        setPlayerForm({ name: '', defense: 3, serving: 3, active: true, star: false });
                                    },
                                    className: "flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
                                }, "Cancel"),
                               React.createElement('div', { className: "flex gap-3 mt-6" },
                                React.createElement('button', {
                                    onClick: () => {
                                        setShowPlayerForm(false);
                                        setEditingPlayer(null);
                                        setPlayerForm({ name: '', defense: 3, serving: 3, active: true, star: false });
                                    },
                                    className: "flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
                                }, "Cancel"),
                                React.createElement('button', {
                                    onClick: editingPlayer ? handleUpdatePlayer : handleAddPlayer,
                                    className: "flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
                                    disabled: !playerForm.name.trim()
                                }, editingPlayer ? 'Update Player' : 'Add Player')
                            )
                        )
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(VolleyballApp), document.getElementById('root'));
    </script>
</body>
</html>
